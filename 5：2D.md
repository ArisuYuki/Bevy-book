## 5.1 Mesh2d

​	在Bevy中，有 `Mesh2d`与`Mesh3d`两种，前者是三角形、矩形、圆形等各种二维形状，后者代表立方体、网格模型等三维物体。`Mesh2d`与`Mesh3d`可以像一个普通的组件一样使用，就像下面一样。在这些代码里，我们生成了一个实体，并在其之上添加了一个`Mesh2d`与对应的`MeshMaterial2d`。

```rust
fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    commands.spawn(Camera2d);

    commands.spawn((
        Mesh2d(meshes.add(Rectangle::default())),
        MeshMaterial2d(materials.add(Color::from(PURPLE))),
        Transform::default().with_scale(Vec3::splat(128.)),
    ));
}
```

​	`Mesh`代表由点组成的集合，他们可能是一个模型、一条线段、或者只是一些点，Bevy，而`ColorMaterial`则代表代表这些形状的颜色、材质等。在Bevy中，二者以`Assets`的形式存在，当使用时，我们应当使用`ResMut`获得该资源并向其中添加真正的数据类型。在`Assets`中我们说过，Bevy加载`Assets`时将返回一个对应的句柄并在后台加载这些数据，因此，创建`Mesh2d`与`MeshMaterial2d`组件时，我们传递的也是一个对应的`Handler`。

​	Bevy在bevy_math::primitives中为我们定义好了一组基本的几何形状，这些形状同样在preload中不需要我们再从bevy_math中导入，如上面的`Rectangle`就是其中的一个形状，这里不再一一赘述，读者可以查看[文档](https://doc.qu1x.dev/bevy_trackball/bevy_math/primitives/index.html)详细了解每种形状的创建方式。

## 5.2 MeshMaterial2d

​	`MeshMaterial2d`描述了Bevy应该如何渲染这些形状的具体信息，如果没有`MeshMaterial2d`只有`Mesh2d`，那么你会发现窗口上不会渲染任何东西。因此，不详细了解`MeshMaterial2d`，那么我们就无法掌握如何渲染这些形状。

### 5.2.1 ColorMaterial

​	`ColorMaterial`是一种二维的材质，其结构体的内容如下。可见，通过`ColorMaterial`我们能够控制的是一个`mesh2d`的颜色、透明度、uv变换、还有材质，下面我们来详细介绍一些其使用方式。

```rust
pub struct ColorMaterial {
    pub color: Color,
    pub alpha_mode: AlphaMode2d,
    pub uv_transform: Affine2,
    #[texture(1)]
    #[sampler(2)]
    pub texture: Option<Handle<Image>>,
}
```

​	在创建`ColorMaterial`时，我们可以直接向其传入上面的四个参数。

```rust
let mesh_handle = meshes.add(Rectangle::from_size(Vec2::splat(256.0)));
commands.spawn((
    //给Mesh2d传入一个形状的句柄
    Mesh2d(mesh_handle),
    //给MeshMaterial2d传入一个ColorMaterial的句柄
    MeshMaterial2d(materials.add(ColorMaterial {
        color: BLUE.into(),
        alpha_mode: AlphaMode2d::Opaque,
        texture: Some(texture_handle.clone()),
        ..default()
    })),
    Transform::from_xyz(-300.0, 0.0, 1.0),
));
```

​	对于第一个参数`color`而言，Bevy给了我们很多的构造方式，这些方式如下。

```rust
//bevy里有一组内置的常用颜色，可以直接引入他们
use bevy::color::palettes::css::{BLUE, GREEN, WHITE};
//或者，我们自己创建颜色结构体Color并传入
use bevy::prelude::*;
let color = Color::hsl(360. * i as f32 / num_shapes as f32, 0.95, 0.7);
```

​	枚举`alpha_mode`用于当我们使用图像做为材质时，对于图像的透明区域该如何处理，其包含三个值`Opaque`，`Mask(f32)`，`Blend`，他们的含义如下。

- `Opaque`：忽略图像的透明通道，使用底色填充（一般为黑色）
- `Mask(f32)`：设置一个阈值，类型为f32，当透明度低于这个值时将被渲染为透明，否则被认为完全不透明
- `Blend`：透明通道不为1时则为半透明颜色，并且会与下面的其他颜色相混合

```rust
use bevy::sprite_render::AlphaMode2d;

MeshMaterial2d(materials.add(ColorMaterial {
    alpha_mode: AlphaMode2d::Opaque,
    ..default()
})),
```

​	`uv_transform`要与`texture`一起使用时才能发挥作用，当我们加载了一个图像并传入时，我们可以通过指定`uv_transform`来决定图像应该如何与形状对其，这是一个二维的[仿射变换](https://doc.qu1x.dev/bevy_trackball/bevy/math/struct.Affine2.html)。

​	在加载图像时，若图像大小小于`Mesh2d`，那么**默认情况下，图像将会在左上角开始被放大到能填满区域为止**，但是当你**指定了`uv_transform`时**，若还不能覆盖整个区域，那么**边缘将会被拉伸到填满区域为止**；若图像大小大于`Mesh2d`，那么将**只会从图像的左上角开始显示**。或者，我们可以指定将图像进行重复显示，这是通过加载图像时指定`settings`做到的。

​	`ImageSamplerDescriptor`里包含了大量的设置，读者可以查看[文档](https://doc.qu1x.dev/bevy_trackball/bevy/image/struct.ImageSamplerDescriptor.html)详细了解，这里我们只使用其uv参数。

```rust
let image_with_repeated_sampler = asset_server.load_with_settings(
    "textures/fantasy_ui_borders/panel-border-010-repeated.png",
    |s: &mut _| {
        *s = ImageLoaderSettings {
            sampler: ImageSampler::Descriptor(ImageSamplerDescriptor {
                // 以重复的模式来加载图像
                address_mode_u: ImageAddressMode::Repeat,
                address_mode_v: ImageAddressMode::Repeat,
                ..default()
            }),
            ..default()
        }
    },
);

//使用时，我们需要指定Affine2来决定重复的次数，如果不指定，那么将默认为1，因此区域将铺满一个图像，而且使用临近插值
//因此，这样不会出现线性插值时导致的边缘模糊问题
MeshMaterial2d(materials.add(ColorMaterial {
    texture: Some(image_with_repeated_sampler),
    // uv_transform used here for proportions only, but it is full Affine2
    // that's why you can use rotation and shift also
    uv_transform: Affine2::from_scale(Vec2::new(2., 3.)),
    ..default()
})),
```

​	现在，我们介绍了`ColorMaterial`的四个重要的参数的使用方法，但是我们仍然缺少一种重要的材质渲染方式，这种方式是GPU最基础的也是功能最强大的，那就是利用顶点属性来渲染颜色。

​	 Mesh结构体上有一个特殊的方法，名叫`insert_attribute`，利用这个方法，我们可以对Mesh的顶点处插入一些属性，并指定这些属性的类型，当拥有这些属性时，wgpu将会自动工作来将其显示在屏幕上。同样，我们也可以移除这些属性，关于其他更多的方法可以查看相关的[文档](https://doc.qu1x.dev/bevy_trackball/bevy/prelude/struct.Mesh.html#method.insert_attribute)。

```rust
let mut mesh = Mesh::from(Rectangle::default());

//顶点属性是一组数组
let vertex_colors: Vec<[f32; 4]> = vec![
    LinearRgba::RED.to_f32_array(),
    LinearRgba::GREEN.to_f32_array(),
    LinearRgba::BLUE.to_f32_array(),
    LinearRgba::WHITE.to_f32_array(),
];

//利用insert_attribute可以插入这些数组，并指定其类型为Mesh::ATTRIBUTE_COLOR
mesh.insert_attribute(Mesh::ATTRIBUTE_COLOR, vertex_colors);

//现在，我们可以使用这个新的mesh作为Mesh2d
let mesh_handle = meshes.add(mesh);	
```

## 5.3 Font

​	字体是2D显示的另一个方面，在Bevy中，我们可以加载自己的字体并显示。

​	字体是后戳为ttf的一些文件，包含了文字应该如何在屏幕上绘制的信息，要加载这些字体，就如同加载普通的`Aeest`一样。

```rust
let font = asset_server.load("fonts/FiraSans-Bold.ttf");
//加载字体之后，我们使用TextFont组件使用它，并指定一些字体的样式，就像使用图片一样
let text_font = TextFont {
    font: font.clone(),
    font_size: 50.0,
    ..default()
};

//将这个组件绑定到某个实体上，并指定一些其他的字体组件，便能显示在屏幕上
commands.spawn((
    Text2d::new(" translation "),
    text_font.clone(),
    TextLayout::new_with_justify(text_justification),
    TextBackgroundColor(Color::BLACK.with_alpha(0.5)),
    Text2dShadow::default(),
));
```

​	在这其中涉及到了大量的字体相关的组件，例如`TextLayout`，`TextBackgroundColor`，`Text2dShadow`，他们的作用不言而喻，通过修改这些组件便可以影响字体的显示效果，读者可以查阅文档来获得详细的信息，这里不再赘述。

## 5.4 Sprite

​	`Sprite`通常翻译为“精灵”，但其实只是另一种形式的图像，通常用于2D游戏的贴图。

### 5.4.1 加载Sprite

​	由于`Sprite`只是一种图像，因此最简单的方式就是直接加载一个图像然后生成，这可以通过以下方式来做到，通过这种方式，生成的贴图将会保持图像的原始尺寸，默认情况下，其中心将位于坐标(0,0)处。

```rust
//Sprite包含了非常多的参数，这些参数我们将在后面一一介绍
pub struct Sprite {
    pub image: Handle<Image>,
    pub texture_atlas: Option<TextureAtlas>,
    pub color: Color,
    pub flip_x: bool,
    pub flip_y: bool,
    pub custom_size: Option<Vec2>,
    pub rect: Option<Rect>,
    pub image_mode: SpriteImageMode,
}


//可以直接使用Sprite结构体来加载
commands.spawn(Sprite {
  image: asset_server.load("sprites/ball.png"),
  ..default()
});
//或者，可以使用一个工厂函数
let image_handle = asset_server.load("sprites/ball.png");
let sprite = Sprite::from_image(image_handle);
commands.spawn(sprite);
```

​	但是很多时候，我们并不是只想将其加载，而是以重复的方式将其铺满整个屏幕，这种方式往往用于将地板等贴图铺满全图。这时，我们可以使用`image_mode`参数，该参数是一个名为`SpriteImageMode` 的枚举类型，其包含以下四个值。

```rust
pub enum SpriteImageMode {
  	//默认为图像的大小
    Auto,
  	//将纹理缩放
    Scale(SpriteScalingMode),
  	//将纹理切片
    Sliced(TextureSlicer),
  	//将纹理重复堆叠，stretch_value用于指定每一片相对于图像大小的缩放比
    Tiled {
        tile_x: bool,
        tile_y: bool,
        stretch_value: f32,
    },
}
```

